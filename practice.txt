/*Objetivo: Escribe una función getOrCreateNotificationPreferences(databases, dbId, collId, userId) que:

Busque en una colección (ej. notificationPreferences) un documento con el userId proporcionado.

Si lo encuentra, devuelva ese documento.

Si no lo encuentra, cree un nuevo documento con el userId y las preferencias por defecto: { emailEnabled: true, pushEnabled: false } y devuelva el nuevo documento.

Pistas: Usa Query.equal, listDocuments, createDocument, ID.unique(). Maneja el caso response.total > 0.*/

async function getOrCreateNotificationPreferences(databases, dbId, collId, userId) {
    try{
        const response = await databases.listDocuments(
            dbId, 
            collId,
            [
                Query.equal('userId', userId),
                Query.limit(1)
            ]

        )
    }
    if(response.total>0){
        return response.documents[0]
    } else {
        const newProfile = await databases.createDocument(
            databaseId,
            collectionId,
            ID.unique,
            {
                userId: userId,
                ...defaultProfileData
            }
        )
        return newProfile
    }
    
}



async function updateUserLastLogin(databases, databaseId, collectionId, documentId){
    try{
        const now= new Date().toISOString()
        const updatedProfile= await databases.updateDocument(
            databaseId,
            collectionId,
            documentId
        ){
            lastlogin:now
        }
        return updatedProfile
    }catch(error){
        console.error("Error en updateUserLastLogin", error)
        throw error
    }
    
}


async function getLevelScore(databases, databaseId, collectionId, userId, levelId){
    try{
        const response= await databases.listDocuments(
            databaseId, collectionId,
            [
                Query.equal('userId',userId),
                Query.equal('levelId', levelId),
                Query.limit(1)
            ]
        )
        if (response.total>0){
            return response.documents[0]
        }else{
            return null
        }
    }catch(error){console.error("error en getlevelscore",error)}

}



async function saveSettings(databases,databaseId,collectionId, [Query.equal('userID', userId)], settingsData)
{
    try{
        const response = await databases.listDocuments(
            databases,databaseId,collectionId,
            [Query.equal('userId', userId), Query.limit(1)] )

            if (response.total>0){
                const documentId=response.documents[0]
                const updatedSettings = await databases.updateDocument(databaseId,collectionId, documentId, settingsData)
                return updatedSettings
            }else{
                const newSettings = await databases.createDocument(
                    databaseId, collectionId, Id.unique(), {userId: userId, ...settingsData}
                )
                return newSettings
            }
    }catch(error){
        console.error("error en savesettings", error)
        throw error
    }

}


async function incrementPlayCount(databases,databaseId,collectionId,songId){
    try{
        const response = await databases.listDocuments(databases,databaseId,collectionId,
            [Query.equal('songId', songId)]
        )
        if(response>0){
            const songDoc=response[0]
            const currentPlayCount=songDoc.playCount || 0
            const documentId =songDoc.$id
            const updatedSong = await databases.updateDocument(
                databaseId,collectionId,documentId,{
                    playCount:currentPlayCount+1
                }
            )
            return updatedSong
        }
    else{
        console.warn(`cancion con songId ${songId} no encontrada`)
        return null
    }

}catch(error){
    console.error("error en incrementPlayCount", error)
    throw Error
}
